<metadata>
1c20cbf4a1d94825c4a872529ee81471dfad9eed462fd8b7482614291d3f5362230d96a6d0f22707eb8e0a64c0a37c13fe9ab1d87a145334f6cb6e4c5c29e5912a4ce3ce00381735c2fd4876cef23b56d9b633572356650975101b3b71076d083c4ea6d5e38addb2fd93c4f9f2d08abb7e50f5c5a88af0ce023edab4c4a50c61a6c3a29c3b6b36579def68090664f996deb2f59c33500a36220df7996203335eb5d0320cd9e580f4b9c0057598fd6f51b5fc127c80e45e3789ea452463176d02c3b1c8f46b440672b6cfdfaf72177a444c709ff3610098f6cea9ef9accadd1b6a4c1122cb0fd603181cd9baf9ca0614ef29e78193759147351244c2dcdaaeb8eba84714de2836d182054e78fe28d5220caf4c8a0f084bfcb05753c0688a74d62bacd592e037490be4b2680e547336302255480f5bcd3c1b53356d1a20e202d432d4804705e71675b3916f49514614632f59db3dc4e3c122c172bb0d3b8d7fa97017197f6cba58df489b7a8eb0867f39e6a1ae081acc2275e87bbf8d7aac93e51127f3040e2836a04ed94754b774b5b38a4cb2f424c212c49c6a87206a6d5be80221e143b2744305f91fc472aee8b325c7c08a2d17f41a894b2d16c030575bcc5601283eacbac81e92450a1d23d036526c5aa1c6c50290674a0c9791e9df567138babeb421f3fb280a2925a6a6054785494b46b269ffab5c16b0ae4b51065a7c8b8cc3e5b45369cbc0a5985ea56303e4a40377c1dc1b3ea8f21015516fe919be9abdb032dd4e8a08fa1c29bf44232dea7e4963e5752354129a2d63340221cc8f462063e5fd3a70b6ea8e75e38fab9cdbf771295f43c481d74d9b6adc36d53af9da7933f11d4e4e9dbe2cce7d53606e6d71829b28e09266602d5b472061772baf56701fdbefa88c4a10c6d57236b02cda21d731628417da9ccd3abccbcabefb0d17004f297aa94f5c56a5b113f172701307759ffcf7545685820118ab6250a6e0bfa822151367297f64e3ad5b0112f536f7f0f20411b68d0a32f585738592b0f6ba39d6f53d2fd6d1d1071dface99ab6c1f9962a582c48a29ce1ddcda8e890dabb701e3d71284937592e49c6f8c696205208677125c7b57819b1d5e782a4d66c20c5a4b6d8deb9c8bdd9b88becfc99e9d59ab5d5b0275f80e10668dd91f0910866c8af95abb98597e588edb6d04421d6a4debbc5abd6b52e4b86f5bf81d6ea6614e580412792f7770588edbcd260035530e9d7287386a3c898ca98fbb4afe886d4d293024f4d68772aa7fba0f05031b1d2ddb674156601680d4437114db3de4233a8c47f4b4e603040fa99e68b4b77f3dcdaa831546b0d1f7a5f2ded88620c6407a4c1e1df8bb789a66b19a5c07e18ea8f87f54025234dbbd8b4d186f5c6f8b68afa93016fb6d2254c3053c6a74f3b6807a5d7c48bf080d2a68be2d9b6cba55d2e29098bf82f4a2656f5944a387b1a70045633edd0684a32745f3ef19d790ad7b2795bbc82d9e5d1bdddb4d0bed7b23919caa4d1b0a3cee88d023f5270e0ac573e107e7b1eefcfe9d888aa82a296f5345b3854a1ce6b19bf827e5ce8c5f6c70f39b780fccd7a4b665ffccfd0e65a78694936454531c9b08ee20d68b68be1c3f1c101232c0c83f4761fa9cd45316f078ab7ae8cb8894a68c5e5d7a44930d6bbbfdd87e8f995310c527017257d4c596eb59785a5f385fb920a7999f070129ef2a2c7370a75570a5e2250a5d0c2a7486a714ffac6bd92bed22f46107ef7929aa429155b74bbd297f9b6d2167f3152fd9ca2d6f29d2f5d36793848e99de48da9c61779e596a19fe6da3e4db5d0186a640d2540592a82bcefa9f091157954277d182e12f0df0f7c61046f1d7e177a1f3b4888b685b9f587d7b207737a2e5b22c0b05d38f4ca1c58c0afa8ddd4b63b5721443509eac5cab8cda8b6c2f3a7730a2c5c10757a445a660a674021f088eaa80362047625566123f3922b48dcb7a69822123b07240b1c71a4c5582035775b3a295bfb887a3898f93457355e4876b9856a0fc0ae4a2b5f3d432fa3c6fbbae38fcbae502281f54b38b886d492a5c497fb2251492c9aa68fa0d2b7583625445e3c90fc6f0a4a0bb1dd82e7fc8e255177043e00ecd071148ce27c1d1b7905692e4b084b177ab5c1d1a3532a003ef4b2a6c7afc3483bc2a7162a99b6b1d4a3cdb6d7086a81ed5a3f6625d7baafdbd4a65920eed0cdf15237dbb51f7e82e0b1ddb2d78bc2355b20544e3c1273c2a07312cfbd685605437b1ac7ab96e54326704c042b6702523c16774c2e563a2144c68f016fa6d2d3a1b3d25537660789fb7648dde1725da2cf08673f5b0a7ffc900663f7c9ee317d32877940da1ca353c29016c767
</metadata>
//+------------------------------------------------------------------+
//|                                                    Parabolic.mq4 |
//|                      Copyright © 2004, MetaQuotes Software Corp. |
//|                                       http://www.metaquotes.net/ |
//+------------------------------------------------------------------+
#property copyright "Copyright © 2004, MetaQuotes Software Corp."
#property link      "http://www.metaquotes.net/"

#property indicator_chart_window
#property indicator_buffers 1
#property indicator_color1 Lime
//---- input parameters
extern double    Step=0.02;
extern double    Maximum=0.2;
//---- buffers
double SarBuffer[];
//----
int    save_lastreverse;
bool   save_dirlong;
double save_start;
double save_last_high;
double save_last_low;
double save_ep;
double save_sar;
//+------------------------------------------------------------------+
//| Custom indicator initialization function                         |
//+------------------------------------------------------------------+
int init()
  {
//---- indicators
   SetIndexStyle(0,DRAW_ARROW);
   SetIndexArrow(0,159);
   SetIndexBuffer(0,SarBuffer);
//----
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void SaveLastReverse(int last,int dir,double start,double low,double high,double ep,double sar)
  {
   save_lastreverse=last;
   save_dirlong=dir;
   save_start=start;
   save_last_low=low;
   save_last_high=high;
   save_ep=ep;
   save_sar=sar;
  }
//+------------------------------------------------------------------+
//| Parabolic Sell And Reverse system                                |
//+------------------------------------------------------------------+
int start()
  {
   static bool first=true;
   bool   dirlong;
   double start,last_high,last_low;
   double ep,sar,price_low,price_high,price;
   int    i,counted_bars=IndicatorCounted();
//----
   if(Bars<3) return(0);
//---- initial settings
   i=Bars-2;
   if(counted_bars==0 || first)
     {
      first=false;
      dirlong=true;
      start=Step;
      last_high=-10000000.0;
      last_low=10000000.0;
      while(i>0)
        {
         save_lastreverse=i;
         price_low=Low[i];
         if(last_low>price_low)   last_low=price_low;
         price_high=High[i];
         if(last_high<price_high) last_high=price_high;
         if(price_high>High[i+1] && price_low>Low[i+1]) break;
         if(price_high<High[i+1] && price_low<Low[i+1]) { dirlong=false; break; }
         i--;
        }
      //---- initial zero
      int k=i;
      while(k<Bars)
        {
         SarBuffer[k]=0.0;
         k++;
        }
      //---- check further
      if(dirlong) { SarBuffer[i]=Low[i+1]; ep=High[i]; }
      else        { SarBuffer[i]=High[i+1]; ep=Low[i]; }
      i--;
     }
    else
     {
      i=save_lastreverse;
      start=save_start;
      dirlong=save_dirlong;
      last_high=save_last_high;
      last_low=save_last_low;
      ep=save_ep;
      sar=save_sar;
     }
//----
   while(i>=0)
     {
      price_low=Low[i];
      price_high=High[i];
      //--- check for reverse
      if(dirlong && price_low<SarBuffer[i+1])
        {
         SaveLastReverse(i,true,start,price_low,last_high,ep,sar);
         start=Step; dirlong=false;
         ep=price_low;  last_low=price_low;
         SarBuffer[i]=last_high;
         i--;
         continue;
        }
      if(!dirlong && price_high>SarBuffer[i+1])
        {
         SaveLastReverse(i,false,start,last_low,price_high,ep,sar);
         start=Step; dirlong=true;
         ep=price_high; last_high=price_high;
         SarBuffer[i]=last_low;
         i--;
         continue;
        }
      //---
      price=SarBuffer[i+1];
      sar=price+start*(ep-price);
      if(dirlong)
        {
         if(ep<price_high && (start+Step)<=Maximum) start+=Step;
         if(price_high<High[i+1] && i==Bars-2)  sar=SarBuffer[i+1];

         price=Low[i+1];
         if(sar>price) sar=price;
         price=Low[i+2];
         if(sar>price) sar=price;
         if(sar>price_low)
           {
            SaveLastReverse(i,true,start,price_low,last_high,ep,sar);
            start=Step; dirlong=false; ep=price_low;
            last_low=price_low;
            SarBuffer[i]=last_high;
            i--;
            continue;
           }
         if(ep<price_high) { last_high=price_high; ep=price_high; }
        }
      else
        {
         if(ep>price_low && (start+Step)<=Maximum) start+=Step;
         if(price_low<Low[i+1] && i==Bars-2)  sar=SarBuffer[i+1];

         price=High[i+1];
         if(sar<price) sar=price;
         price=High[i+2];
         if(sar<price) sar=price;
         if(sar<price_high)
           {
            SaveLastReverse(i,false,start,last_low,price_high,ep,sar);
            start=Step; dirlong=true; ep=price_high;
            last_high=price_high;
            SarBuffer[i]=last_low;
            i--;
            continue;
           }
         if(ep>price_low) { last_low=price_low; ep=price_low; }
        }
      SarBuffer[i]=sar;
      i--;
     }
//   sar=SarBuffer[0];
//   price=iSAR(NULL,0,Step,Maximum,0);
//   if(sar!=price) Print("custom=",sar,"   SAR=",price,"   counted=",counted_bars);
//   if(sar==price) Print("custom=",sar,"   SAR=",price,"   counted=",counted_bars);
//----
   return(0);
  }
//+------------------------------------------------------------------+