//+------------------------------------------------------------------+
//|                                             AmazingCrossover.mq4 |
//|                                     Babypips and The Lazy Trader |
//|                                   http://www.the-lazy-trader.com |
//+------------------------------------------------------------------+
#property copyright "Babypips and the-lazy-trader.com"
#property link      "www.babypips.com & www.the-lazy-trader.com"

/*Parameters*/
extern double Lot_Size = 1;
extern int Ema_Period_1 = 5;
extern int Ema_Period_2 = 10;
extern int RSI_Period = 10;
extern double Take_Profit = 100.0;
extern double Stop_Loss = 50.0;
extern double Trailing_Stop = 50.0;


/*Internal Global Variables*/
string System_Name = "Amazing Crossover";
int MagicNumber = 23845555;
bool NewBarFlag = false;                         // Flag of a new bar
static datetime NewTime;

int init()
{
    NewTime = Time[0];  
    return(0);
}


int start() 
{
   /* If there is existing order analyze if stop loss needs to be moved */
   if (ThereIsAlreadyATrade()) 
   {
       ManageStopLoss();           
   }   
   
   /*Only enter new trades when there is a new bar*/
   AnalyzeNewBar();  
      
   if (NewBarFlag == true)   
   {
       AnalyzeNewOrderEntry(); 
   }   
                 
   return(0);
}

void AnalyzeNewBar()                           
{                                             
    NewBarFlag = false;                             
    if(NewTime != Time[0])                       
    {
        NewTime = Time[0];                      
        NewBarFlag = true;      //New bar detected         
    }
}

 
bool ThereIsAlreadyATrade()
{
    bool found = false;
    int totalOrders = OrdersTotal();
    int i = 0;
    while ((!found) && (i < totalOrders))
    {
         if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES ) == true) // If there is the next one
         {                                       
              if (OrderSymbol() == Symbol())
              {
                  //Verify you are dealing with an order generated by this system 
                  if (OrderMagicNumber() == MagicNumber)
                      found = true;     
              }                  
         }
         i++;
    }
    return (found);
}


void ManageStopLoss()
{
    if (Trailing_Stop <= 0)
        return;
    
    double pipsDistanceOpenPrice;
    double newStopLoss;
    double ratio;
    bool found = false;
    int i = 0;
    while (!found)
    {
         if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES ) == true) // If there is the next one
         {                                       
              if (OrderSymbol() == Symbol())
              {
                  int magicNumber = OrderMagicNumber();
                  //Verify you are dealing with an order generated by the System
                  if (magicNumber == MagicNumber)
                  {       
                      int orderTicket = OrderTicket();             // Number of selected order
                      double orderOpenPrice = OrderOpenPrice();       // Price of selected order
                      double orderStopLoss = OrderStopLoss();         // SL of selected order
                      double orderLots = OrderLots();                 // Number of lots
                      double orderTakeProfit = OrderTakeProfit();
                                            
                      if (OrderType() == OP_BUY) //Raise stop loss
                      {
                          //verify that stop loss is farther than Trailing_Stop
                          pipsDistanceOpenPrice = Bid - orderOpenPrice;
                          ratio = MathFloor( pipsDistanceOpenPrice/( Trailing_Stop * GetPipRange())  );
                          
                          if (ratio >= 1)
                          {
                              newStopLoss = orderOpenPrice + ((ratio - 1) * Trailing_Stop * GetPipRange()) ;
                              if (orderStopLoss < newStopLoss )
                              {
                                   //move up stop loss
                                   OrderModify(orderTicket, orderOpenPrice, newStopLoss, orderTakeProfit, 0, Orange);                                  
                              }
                          }                        
                                                    
                      }
                  
                      if (OrderType() == OP_SELL) //Lower stop loss 
                      {
                          pipsDistanceOpenPrice = orderOpenPrice - Ask;
                          ratio = MathFloor( pipsDistanceOpenPrice/( Trailing_Stop * GetPipRange())  );
                          
                          if (ratio >= 1)
                          {
                              newStopLoss = orderOpenPrice - ((ratio - 1) * Trailing_Stop * GetPipRange()) ;
                              if (orderStopLoss > newStopLoss )
                              {
                                   //move up stop loss
                                   OrderModify(orderTicket, orderOpenPrice, newStopLoss, orderTakeProfit, 0, Orange);                                  
                              }
                          }
                      }
                      found = true; 
                  }   
              }
          }   
          else
          {
              Print("OrderSelect() returned error - ", GetLastError());
          }
          i++;
     }    
}

bool AnalyzeNewOrderEntry()
{
    RefreshRates();
    double stopLoss;
    double targetPoint;
    int ticket;
    double pipRange = GetPipRange();
    
    if (BullConditionsExist() && !CurrentSignalHasBeenPlayed() )
    {
        CloseBearPosition();
    
        //If there is already bull position open dont do anything
        if (ThereIsAlreadyATrade())
            return (false);
        
        stopLoss = Ask - Stop_Loss * pipRange;
        targetPoint = Ask + Take_Profit * pipRange; 
                     
        //Enter long trade
        if (Lot_Size > 0)
        {
            ticket = OrderSend(Symbol(),OP_BUY, Lot_Size, Ask, 2, stopLoss, targetPoint, System_Name, MagicNumber); 
            if (ticket < 0)
            {
                Print("Long OrderSend failed with error #", GetLastError());
                return (false);
            }
            else
            {
                Print("Long Order entered Bought at: " + Ask + " SL: " + stopLoss + " TP: " +  targetPoint);
                return(true);
            }
        }
    }
    
    if (BearConditionsExist() && !CurrentSignalHasBeenPlayed() )
    {
        CloseBullPosition();
        
        if (ThereIsAlreadyATrade())
            return (false);
            
        stopLoss = Bid + Stop_Loss * pipRange;
        targetPoint = Bid - Take_Profit * pipRange;
                
        //Enter short trade
        if (Lot_Size > 0)
        {
            ticket = OrderSend(Symbol(),OP_SELL, Lot_Size, Bid, 2, stopLoss, targetPoint, System_Name, MagicNumber); 
            if(ticket < 0)
            {
                Print("Short OrderSend failed with error #", GetLastError());
                return (false);
            }
            else
            {
                Print("Short Order entered Sold at: " + Bid + " SL: " + stopLoss + " TP: " +  targetPoint);
                return (true);
            }
        }                
    }
    return (false);
}

bool BullConditionsExist()
{
    if (RsiIsBullish() && EmaBullishCrossOver())
        return (true);
    else
        return (false);
}

bool BearConditionsExist()
{
    if (RsiIsBearish() && EmaBearishCrossOver())
        return (true);
    else
        return (false);
}

bool RsiIsTrendingUp()
{
    double rsiPrevious1 = iRSI(NULL, 0, RSI_Period, PRICE_MEDIAN, 1);
    double rsiPrevious2 = iRSI(NULL, 0, RSI_Period, PRICE_MEDIAN, 2);
        
    return (rsiPrevious1 > rsiPrevious2);
}

bool RsiIsBullish()
{
    double rsiPrevious1 = iRSI(NULL, 0, RSI_Period, PRICE_MEDIAN, 1);
    return (rsiPrevious1 > 48);
}

bool RsiIsTrendingDown()
{
    double rsiPrevious1 = iRSI(NULL, 0, RSI_Period, PRICE_MEDIAN, 1);
    double rsiPrevious2 = iRSI(NULL, 0, RSI_Period, PRICE_MEDIAN, 2);
        
    return (rsiPrevious1 < rsiPrevious2);
}

bool RsiIsBearish()
{
    double rsiPrevious1 = iRSI(NULL, 0, RSI_Period, PRICE_MEDIAN, 1);
    return (rsiPrevious1 < 52);
}

bool EmaBullishCrossOver()
{
    double emaShortPeriod = iMA(NULL, 0, Ema_Period_1, 0, MODE_EMA,PRICE_CLOSE, 1);
    double emaLongPeriod = iMA(NULL, 0, Ema_Period_2, 0, MODE_EMA,PRICE_CLOSE, 1);
    
    return  (emaShortPeriod > emaLongPeriod);    
}

bool EmaBearishCrossOver()
{
    double emaShortPeriod = iMA(NULL, 0, Ema_Period_1, 0, MODE_EMA,PRICE_CLOSE, 1);
    double emaLongPeriod = iMA(NULL, 0, Ema_Period_2, 0, MODE_EMA,PRICE_CLOSE, 1);
    
    return  (emaShortPeriod < emaLongPeriod);    
}

void CloseBearPosition()
{
    int totalOrders = OrdersTotal();
    int i = 0;
    while (i < totalOrders)
    {
         if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES ) == true) // If there is the next one
         {                                       
              if (OrderSymbol() == Symbol())
              {
                  //Verify you are dealing with an order generated by the Forex Threat System
                  if (OrderMagicNumber() == MagicNumber)
                  {
                      if (OrderType() == OP_SELL) 
                          OrderClose(OrderTicket(), OrderLots(), Ask, 2);
                  }     
              }                  
         }
         i++;
    }
    return;
}

void CloseBullPosition()
{
    int totalOrders = OrdersTotal();
    int i = 0;
    while (i < totalOrders)
    {
         if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES ) == true) // If there is the next one
         {                                       
              if (OrderSymbol() == Symbol())
              {
                  //Verify you are dealing with an order generated by the Forex Threat System
                  if (OrderMagicNumber() == MagicNumber)
                  {
                      if (OrderType() == OP_BUY) 
                          OrderClose(OrderTicket(), OrderLots(), Bid, 2);
                  }     
              }                  
         }
         i++;
    }
    return;
}

double GetPipRange()
{
    if (StringFind(Symbol(), "USD", 0) > 0)
        return (0.01);
    else
        return (0.0001);
}


/*This function needs to determine if the current signal was already played and exited so as not to enter 
the same trade in another candle bar*/
bool CurrentSignalHasBeenPlayed()
{
    //Get time of the last Ema crossover
    datetime lastCrossOverTime = GetLastCrossoverTime();
    
    //Get OpenTime of the most recent trade
    datetime lastTradeOpenTime = GetLastTradeOpenTime();
    
    if (lastCrossOverTime > lastTradeOpenTime) 
        return (false); //Current signal has not been played yet
    else
        return (true); //Current signal was already played
}


datetime GetLastCrossoverTime()
{
    //First we need to find the time of the most recent Ema crossover
    double emaShortPeriod = iMA(NULL, 0, Ema_Period_1, 0, MODE_EMA,PRICE_CLOSE, 1);
    double emaLongPeriod = iMA(NULL, 0, Ema_Period_2, 0, MODE_EMA,PRICE_CLOSE, 1);
    bool crossOverFound = false;
    int i = 2;
    double emaShort;
    double emaLong;
    datetime lastCrossOverTime;
    if (emaShortPeriod > emaLongPeriod) //the most recent was a bullish crossover
    {
        while (!crossOverFound)
        {
            emaShort = iMA(NULL, 0, Ema_Period_1, 0, MODE_EMA,PRICE_CLOSE, i);
            emaLong = iMA(NULL, 0, Ema_Period_2, 0, MODE_EMA,PRICE_CLOSE, i);
            if (emaLong > emaShort)
            {
                crossOverFound = true;
                lastCrossOverTime = Time[i - 1];   
            }
            else
               i++;
        }        
    }
    else if (emaLongPeriod > emaShortPeriod) //the most recent was a bearish crossover
    {
        while (!crossOverFound)
        {
            emaShort = iMA(NULL, 0, Ema_Period_1, 0, MODE_EMA,PRICE_CLOSE, i);
            emaLong = iMA(NULL, 0, Ema_Period_2, 0, MODE_EMA,PRICE_CLOSE, i);
            if (emaShort > emaLong)
            {
                crossOverFound = true;
                lastCrossOverTime = Time[i - 1];   
            }
            else
               i++;
        }
    }   
    
    return (lastCrossOverTime);
}

datetime GetLastTradeOpenTime()
{
    int totalOrders = OrdersHistoryTotal();
    int i = 0;
    datetime mostRecentTime = D'1980.01.01 00:00';     
    
    while (i < totalOrders)
    {
         if (OrderSelect(i, SELECT_BY_POS, MODE_HISTORY ) == true) // If there is the next one
         {                                       
              if (OrderSymbol() == Symbol())
              {
                  //Verify you are dealing with an order generated by this system 
                  if (OrderMagicNumber() == MagicNumber)
                  {
                      if ( OrderOpenTime() > mostRecentTime )
                          mostRecentTime = OrderOpenTime();
                  }     
              }                  
         }
         i++;
    }
    return (mostRecentTime);
}
 